<!DOCTYPE html>
<html>
  <head>
    <script src='js/three.min.js'></script>
    <script src='js/mkmesh.js'></script>
    <script src='pdbs/1ake.json'></script>
    <title>kinky kinase</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
      font-family: Monospace;
      background-color: #f0f0f0;
      margin: 0px;
      overflow: hidden;
    }
    </style>
    </head>
<body>
  <script>
  var camera, scene, renderer;

  var container;
  var parent;
  var animation = true;
  function init() {
    container = document.createElement('div');
    document.body.appendChild(container);

    var aspect = window.innerWidth/window.innerHeight;
    spline_camera = new THREE.PerspectiveCamera(50, aspect,
                                         1, 1000);
    camera = new THREE.PerspectiveCamera(50, aspect,
                                         1, 1000);

    scene = new THREE.Scene();

    var  light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0, 0, 1);
    scene.add(light);

    parent = new THREE.Object3D();
    scene.add(parent);

    function add_geometry(geometry, color, x, y, z, rx, ry, rz, s) {
      // to be written...
      var materials = [
      new THREE.MeshLambertMaterial({ color: color, opacity : 0.2, 
                                      transparent : true }),
      new THREE.MeshBasicMaterial({color: 0x000000, wireframe : true, 
                                   opacity : 0.3})
      ]
      var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, 
                                                            materials);
      mesh.position.set(x, y, z);
      mesh.scale.set(s, s, s);
      mesh.rotation.set(rx, ry, rz);
      parent.add(mesh);
      return mesh;
    }

    tube = make_mesh(KINASE);
    var mesh = add_geometry(tube, 0xff1100, 0, 0, 0, 0, 0, 0, 1);
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( window.innerWidth, window.innerHeight );

    container.appendChild(renderer.domElement);
    renderer.domElement.addEventListener('mousedown', mouse_down, false);
    renderer.domElement.addEventListener('mousewheel', mouse_wheel, false);
    mesh.children[0].geometry.computeBoundingBox();
    var bb = mesh.children[0].geometry.boundingBox;
    center = bb.min.add(bb.max).multiplyScalar(0.5);
    camera.matrixAutoUpdate = false;
    rot = new THREE.Matrix4();
    scale = 1;
    update_cam();
  }

  function animate() {
    var time = Date.now();
    var loop_time = 20 * 10000;
    var t = (time % loop_time) / loop_time;
    var pos = tube.path.getPointAt(t);
    var segments = tube.tangents.length;
    var pickt = t * segments;
    var pick = Math.floor( pickt);
    var pick_next = (pick + 1) % segments;
    var binormal = new THREE.Vector3();
    binormal.subVectors(tube.binormals[pick_next], tube.binormals[pick]);
    binormal.multiplyScalar(pickt-pick).add(tube.binormals[pick]);
    var dir = tube.path.getTangentAt(t);
    var normal = new THREE.Vector3();
    normal.copy(binormal).cross(dir);
    var offset = 1.5;
    pos.add(normal.clone().multiplyScalar(offset));
    spline_camera.position = pos;
    var look_at = new THREE.Vector3();
    var x = new THREE.Vector3();
    x.copy(normal).multiplyScalar(-0.5);

    //look_at.copy(pos).add(dir).add(x);
    var look_at = tube.path.getPointAt(t+0.002);
    spline_camera.matrix.lookAt(spline_camera.position, look_at, normal);
    spline_camera.rotation.setEulerFromRotationMatrix(spline_camera.matrix, spline_camera.eulerOrder);
    requestAnimationFrame(animate);
    render();
  }

  function mouse_down(event) {
    event.preventDefault();
    renderer.domElement.addEventListener('mousemove', mouse_move, false);
    renderer.domElement.addEventListener('mouseup', mouse_up, false);
    renderer.domElement.addEventListener('mouseout', mouse_out, false);
    last_mouse_pos = new THREE.Vector2(event.pageX, event.pageY);
  }
  function update_cam() {
    var cam_matrix = new THREE.Matrix4();
    cam_matrix.translate(center);
    cam_matrix.multiplyMatrices(cam_matrix, rot);
    var trans = new THREE.Vector3(0, 0, 100);
    trans.multiplyScalar(scale);
    cam_matrix.translate(trans);
    camera.matrix = cam_matrix;
    camera.updateMatrixWorld(true);
  }

  function mouse_wheel(event) {
     var delta = 1+event.wheelDelta*0.0001;
     scale *= delta;
     update_cam();
  }

  function mouse_move(event) {
    var new_mouse_pos = new THREE.Vector2(event.pageX, event.pageY);
    var delta = last_mouse_pos.sub(new_mouse_pos);
    var speed = 0.005;
    rot.rotateByAxis(new THREE.Vector3(1, 0, 0), delta.y*speed);
    rot.rotateByAxis(new THREE.Vector3(0, 1, 0), delta.x*speed);
    update_cam();
    last_mouse_pos =  new_mouse_pos;
  }

  function mouse_out(event) {}

  function mouse_up(event) {
    renderer.domElement.removeEventListener('mousemove', mouse_move, false);
    renderer.domElement.removeEventListener('mouseup', mouse_up, false);
    renderer.domElement.removeEventListener('mouseout', mouse_out, false);
  }

  function render() {
    renderer.render(scene, animation ? spline_camera : camera);
  }

  init();
  animate();

  </script>
</body>
</html>
