<!DOCTYPE html>
<html>
  <head>
    <script src='js/three.min.js'></script>
    <script src='js/mkmesh.js'></script>
    <script src='pdbs/1crn.json'></script>
    <title>kinky kinase</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
      font-family: Monospace;
      background-color: #f0f0f0;
      margin: 0px;
      overflow: hidden;
    }
    </style>
    </head>
<body>
  <script>
  var camera, scene, renderer;

  var container;
  var parent;
  var animation = true;

  function init() {
    container = document.createElement('div');
    document.body.appendChild(container);

    var aspect = window.innerWidth/window.innerHeight;
    spline_camera = new THREE.PerspectiveCamera(50, aspect,
                                         1, 1000);
    camera = new THREE.PerspectiveCamera(50, aspect,
                                         1, 1000);

    scene = new THREE.Scene();
    var ambient_light = new THREE.AmbientLight(0x404040); // soft white light
    scene.add(ambient_light);
    light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0, 0, 1);
    scene.add(light);
    parent = new THREE.Object3D();
    scene.add(parent);

    function add_geometry(geometry, color, x, y, z, rx, ry, rz, s) {
      var materials = [
      new THREE.MeshLambertMaterial({ color: color, opacity : 1.0, 
                                      transparent : false }),
      new THREE.MeshBasicMaterial({color: 0x000000, wireframe : true, 
                                   opacity : 1.0})
      ]
      var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, 
                                                            materials);
      mesh.position.set(x, y, z);
      mesh.scale.set(s, s, s);
      mesh.rotation.set(rx, ry, rz);
      parent.add(mesh);
      return mesh;
    }

    tube = make_mesh(CRAMBIN);
    var v = Vehicle(0.6, 0.3);
    var mesh = add_geometry(tube, 0xff1100, 0, 0, 0, 0, 0, 0, 1);
    vehicle = add_geometry(v, 0x11ff00, 0, 0, 0, 0, 0, 0, 1);
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    //renderer = new THREE.CanvasRenderer( { antialias: true } );
    renderer.setSize( window.innerWidth, window.innerHeight );

    container.appendChild(renderer.domElement);
    renderer.domElement.addEventListener('mousedown', mouse_down, false);
    renderer.domElement.addEventListener('mousewheel', mouse_wheel, false);
    document.addEventListener('keydown', key_down, false);
    document.addEventListener('keyup', key_up, false);
    mesh.children[0].geometry.computeBoundingBox();
    var bb = mesh.children[0].geometry.boundingBox;
    center = bb.min.add(bb.max).multiplyScalar(0.5);
    //center = new THREE.Vector3(0,0,0);
    camera.matrixAutoUpdate = false;
    rot = new THREE.Matrix4();
    scale = 1;
    update_cam();
  }

  function animate() {
    var time = Date.now();
    var loop_time = 20 * 10000;
    var look_ahead_delta_t = 5*tube.tangents.length/loop_time;
    var t = (time % loop_time) / loop_time;
    var pos = tube.path.getPointAt(t);
    var segments = tube.tangents.length;
    var pickt = t * segments;
    var pick = Math.floor( pickt);
    var pick_next = (pick + 1) % segments;
    var binormal = new THREE.Vector3();
    binormal.subVectors(tube.binormals[pick_next], tube.binormals[pick]);
    binormal.multiplyScalar(pickt-pick).add(tube.binormals[pick]);
    var dir = tube.path.getTangentAt(t);
    var normal = new THREE.Vector3();
    normal.copy(binormal).cross(dir);
    var offset = 1.5;
    pos.add(normal.clone().multiplyScalar(offset));
    spline_camera.position = pos;
    var look_at = new THREE.Vector3();
    var x = new THREE.Vector3();
    x.copy(normal).multiplyScalar(-0.5);
    var look_at = tube.path.getPointAt(t+look_ahead_delta_t);
    vehicle.position = look_at;
    vehicle.matrixAutoUpdate = false;
    var hdir = tube.path.getTangentAt(t+look_ahead_delta_t); 
    var center = new THREE.Vector3();
    center.copy(look_at).add(hdir);
    var la = new THREE.Matrix4();
    la.lookAt(look_at, center, normal);
    vehicle.matrix.identity();
    vehicle.matrix.translate(look_at);
    vehicle.matrix.multiply(la);
    vehicle.updateMatrixWorld(true);
    spline_camera.matrix.lookAt(spline_camera.position, look_at, normal);
    light.position.applyMatrix4(spline_camera.matrix);
    spline_camera.rotation.setEulerFromRotationMatrix(spline_camera.matrix, 
                                                      spline_camera.eulerOrder);
    requestAnimationFrame(animate);
    render();
  }

  function key_down(event) {
    //event.preventDefault();
    if (event.keyCode == 74) {
      left_down = true;
    }
    if (event.keyCode == 75) {
      right_down = true;
    }
  }

  function key_up(event) {
    if (event.keyCode == 74) {
      left_down = false;
    }
    if (event.keyCode == 75) {
      right_down = false;
    }
  }

  function mouse_down(event) {
    event.preventDefault();
    renderer.domElement.addEventListener('mousemove', mouse_move, false);
    renderer.domElement.addEventListener('mouseup', mouse_up, false);
    renderer.domElement.addEventListener('mouseout', mouse_out, false);
    last_mouse_pos = new THREE.Vector2(event.pageX, event.pageY);
  }
  function update_cam() {
    var cam_matrix = new THREE.Matrix4();
    cam_matrix.translate(center);
    cam_matrix.multiplyMatrices(cam_matrix, rot);
    var trans = new THREE.Vector3(0, 0, 100);
    trans.multiplyScalar(scale);
    cam_matrix.translate(trans);
    camera.matrix = cam_matrix;
    camera.updateMatrixWorld(true);
  }

  function mouse_wheel(event) {
     var delta = 1+event.wheelDelta*0.0001;
     scale *= delta;
     update_cam();
  }

  function mouse_move(event) {
    var new_mouse_pos = new THREE.Vector2(event.pageX, event.pageY);
    var delta = last_mouse_pos.sub(new_mouse_pos);
    var speed = 0.005;
    rot.rotateByAxis(new THREE.Vector3(1, 0, 0), delta.y*speed);
    rot.rotateByAxis(new THREE.Vector3(0, 1, 0), delta.x*speed);
    update_cam();
    last_mouse_pos =  new_mouse_pos;
  }

  function mouse_out(event) {}

  function mouse_up(event) {
    renderer.domElement.removeEventListener('mousemove', mouse_move, false);
    renderer.domElement.removeEventListener('mouseup', mouse_up, false);
    renderer.domElement.removeEventListener('mouseout', mouse_out, false);
  }

  function render() {
    renderer.render(scene, animation ? spline_camera : camera);
  }

  init();
  animate();

  </script>
</body>
</html>
